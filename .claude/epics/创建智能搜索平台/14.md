---
id: 005
title: 三层权限管理系统
epic: 创建智能搜索平台
status: pending
priority: high
assignee: ""
labels: ["权限管理", "JWT认证", "RBAC", "安全", "缓存"]
created: 2025-09-20T02:23:58Z
updated: 2025-09-20T02:45:31Z
estimate: L
parallel: true
dependencies: [001]
---

# 三层权限管理系统

## 描述

实现智能搜索平台的三层权限管理架构：空间(Space) → 渠道(Channel) → 角色(Role)。提供细粒度的权限控制，支持JWT认证、动态权限配置、权限缓存策略和审计日志。确保搜索平台的数据安全和访问控制合规性。

## 验收标准

- [ ] JWT Token验证响应时间 < 10ms (99百分位)
- [ ] 权限检查响应时间 < 5ms (缓存命中)
- [ ] 权限缓存命中率 > 90%
- [ ] 支持并发10000用户权限验证
- [ ] 权限配置变更实时生效 < 100ms
- [ ] 审计日志完整性 100% (所有权限操作)
- [ ] 密码加密强度符合OWASP标准
- [ ] Session管理支持分布式集群
- [ ] 权限继承准确率 100%
- [ ] 角色权限矩阵一致性检查通过

## 技术细节

### 三层权限架构

**权限模型设计**
```java
// 空间 - 最高层级，通常对应组织或部门
@Entity
@Table(name = "spaces")
public class Space {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String code; // 空间编码

    @Column(nullable = false)
    private String name; // 空间名称

    private String description;

    @Enumerated(EnumType.STRING)
    private SpaceStatus status; // ACTIVE, INACTIVE, SUSPENDED

    @OneToMany(mappedBy = "space", cascade = CascadeType.ALL)
    private List<Channel> channels;

    @OneToMany(mappedBy = "space")
    private List<UserSpaceRole> userSpaceRoles;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @UpdateTimestamp
    private LocalDateTime updatedAt;
}

// 渠道 - 中间层级，对应业务线或项目
@Entity
@Table(name = "channels")
public class Channel {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String code; // 渠道编码

    @Column(nullable = false)
    private String name; // 渠道名称

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "space_id", nullable = false)
    private Space space;

    @Enumerated(EnumType.STRING)
    private ChannelType type; // PUBLIC, PRIVATE, RESTRICTED

    @OneToMany(mappedBy = "channel")
    private List<UserChannelRole> userChannelRoles;

    @OneToMany(mappedBy = "channel")
    private List<Document> documents;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

// 角色 - 最细粒度权限控制
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String code; // 角色编码

    @Column(nullable = false)
    private String name; // 角色名称

    @Enumerated(EnumType.STRING)
    private RoleType type; // SYSTEM, CUSTOM

    @Enumerated(EnumType.STRING)
    private RoleLevel level; // SPACE, CHANNEL, DOCUMENT

    @OneToMany(mappedBy = "role", cascade = CascadeType.ALL)
    private List<RolePermission> permissions;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

**用户权限关联**
```java
// 用户-空间-角色关联
@Entity
@Table(name = "user_space_roles")
public class UserSpaceRole {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "space_id", nullable = false)
    private Space space;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "role_id", nullable = false)
    private Role role;

    @Column(name = "granted_by")
    private Long grantedBy; // 授权人ID

    @Column(name = "expires_at")
    private LocalDateTime expiresAt; // 权限到期时间

    @Enumerated(EnumType.STRING)
    private PermissionStatus status; // ACTIVE, SUSPENDED, REVOKED

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

// 用户-渠道-角色关联
@Entity
@Table(name = "user_channel_roles")
public class UserChannelRole {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "channel_id", nullable = false)
    private Channel channel;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "role_id", nullable = false)
    private Role role;

    @Column(name = "granted_by")
    private Long grantedBy;

    @Column(name = "expires_at")
    private LocalDateTime expiresAt;

    @Enumerated(EnumType.STRING)
    private PermissionStatus status;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

### JWT认证系统

**JWT服务实现**
```java
@Service
public class JwtAuthenticationService {

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration:86400}") // 24小时
    private int jwtExpiration;

    @Value("${app.jwt.refresh-expiration:604800}") // 7天
    private int refreshTokenExpiration;

    @Autowired
    private UserService userService;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    public AuthenticationResponse authenticate(AuthenticationRequest request) {
        // 1. 用户验证
        User user = userService.validateUser(request.getUsername(), request.getPassword());
        if (user == null) {
            throw new BadCredentialsException("Invalid credentials");
        }

        // 2. 生成JWT Token
        String accessToken = generateAccessToken(user);
        String refreshToken = generateRefreshToken(user);

        // 3. 缓存用户权限信息
        cacheUserPermissions(user.getId(), accessToken);

        // 4. 记录登录日志
        auditService.logAuthentication(user.getId(), request.getClientInfo());

        return AuthenticationResponse.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .expiresIn(jwtExpiration)
            .tokenType("Bearer")
            .user(UserDto.from(user))
            .build();
    }

    private String generateAccessToken(User user) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpiration * 1000);

        // 构建权限声明
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", user.getId());
        claims.put("username", user.getUsername());
        claims.put("roles", getUserRoleCodes(user));
        claims.put("permissions", getUserPermissions(user));

        return Jwts.builder()
            .setClaims(claims)
            .setSubject(user.getUsername())
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(SignatureAlgorithm.HS512, jwtSecret)
            .compact();
    }

    public boolean validateToken(String token) {
        try {
            // 1. JWT签名验证
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token);

            // 2. 检查Token是否被吊销
            String tokenId = getTokenId(token);
            Boolean isRevoked = (Boolean) redisTemplate.opsForValue()
                .get("revoked_token:" + tokenId);

            return !Boolean.TRUE.equals(isRevoked);
        } catch (JwtException | IllegalArgumentException e) {
            logger.error("Invalid JWT token: {}", e.getMessage());
            return false;
        }
    }
}
```

**权限拦截器**
```java
@Component
public class PermissionInterceptor implements HandlerInterceptor {

    @Autowired
    private PermissionService permissionService;

    @Autowired
    private JwtAuthenticationService jwtService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler) throws Exception {

        // 1. 检查是否需要权限验证
        if (!requiresPermission(handler)) {
            return true;
        }

        // 2. 提取JWT Token
        String token = extractToken(request);
        if (token == null || !jwtService.validateToken(token)) {
            sendUnauthorizedResponse(response);
            return false;
        }

        // 3. 获取用户信息
        String username = jwtService.getUsernameFromToken(token);
        User user = userService.findByUsername(username);

        // 4. 权限检查
        RequirePermission annotation = getPermissionAnnotation(handler);
        if (annotation != null) {
            boolean hasPermission = permissionService.checkPermission(
                user.getId(),
                annotation.resource(),
                annotation.action(),
                extractResourceId(request)
            );

            if (!hasPermission) {
                sendForbiddenResponse(response);
                return false;
            }
        }

        // 5. 设置用户上下文
        SecurityContextHolder.getContext().setAuthentication(
            new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities())
        );

        return true;
    }
}
```

### 权限检查服务

**细粒度权限检查**
```java
@Service
public class PermissionService {

    @Autowired
    private UserPermissionRepository userPermissionRepository;

    @Autowired
    private PermissionCacheService cacheService;

    @Autowired
    private PermissionInheritanceService inheritanceService;

    public boolean checkPermission(Long userId, String resource, String action, Long resourceId) {
        // 1. 构建权限检查键
        String permissionKey = buildPermissionKey(userId, resource, action, resourceId);

        // 2. 检查缓存
        Boolean cachedResult = cacheService.getCachedPermission(permissionKey);
        if (cachedResult != null) {
            return cachedResult;
        }

        // 3. 执行权限检查
        boolean hasPermission = performPermissionCheck(userId, resource, action, resourceId);

        // 4. 缓存结果
        cacheService.cachePermission(permissionKey, hasPermission);

        return hasPermission;
    }

    private boolean performPermissionCheck(Long userId, String resource, String action, Long resourceId) {
        // 1. 直接权限检查
        if (hasDirectPermission(userId, resource, action, resourceId)) {
            return true;
        }

        // 2. 继承权限检查
        if (inheritanceService.hasInheritedPermission(userId, resource, action, resourceId)) {
            return true;
        }

        // 3. 组权限检查
        if (hasGroupPermission(userId, resource, action, resourceId)) {
            return true;
        }

        // 4. 超级管理员检查
        if (isSuperAdmin(userId)) {
            return true;
        }

        return false;
    }

    private boolean hasDirectPermission(Long userId, String resource, String action, Long resourceId) {
        // 检查用户在特定资源上的直接权限
        return userPermissionRepository.existsByUserIdAndResourceAndActionAndResourceId(
            userId, resource, action, resourceId);
    }
}
```

**权限继承服务**
```java
@Service
public class PermissionInheritanceService {

    public boolean hasInheritedPermission(Long userId, String resource, String action, Long resourceId) {
        // 1. 空间级权限继承
        if (hasSpaceLevelPermission(userId, resource, action, resourceId)) {
            return true;
        }

        // 2. 渠道级权限继承
        if (hasChannelLevelPermission(userId, resource, action, resourceId)) {
            return true;
        }

        // 3. 父资源权限继承
        if (hasParentResourcePermission(userId, resource, action, resourceId)) {
            return true;
        }

        return false;
    }

    private boolean hasSpaceLevelPermission(Long userId, String resource, String action, Long resourceId) {
        // 查找资源所属的空间
        Long spaceId = getResourceSpaceId(resource, resourceId);
        if (spaceId == null) {
            return false;
        }

        // 检查用户在该空间的权限
        List<UserSpaceRole> spaceRoles = userSpaceRoleRepository.findByUserIdAndSpaceId(userId, spaceId);

        for (UserSpaceRole spaceRole : spaceRoles) {
            if (roleHasPermission(spaceRole.getRole(), resource, action)) {
                return true;
            }
        }

        return false;
    }

    private boolean hasChannelLevelPermission(Long userId, String resource, String action, Long resourceId) {
        // 查找资源所属的渠道
        Long channelId = getResourceChannelId(resource, resourceId);
        if (channelId == null) {
            return false;
        }

        // 检查用户在该渠道的权限
        List<UserChannelRole> channelRoles = userChannelRoleRepository.findByUserIdAndChannelId(userId, channelId);

        for (UserChannelRole channelRole : channelRoles) {
            if (roleHasPermission(channelRole.getRole(), resource, action)) {
                return true;
            }
        }

        return false;
    }
}
```

### 权限缓存策略

**多级缓存架构**
```java
@Service
public class PermissionCacheService {

    // L1缓存 - 进程内缓存
    private final Cache<String, Boolean> l1Cache = Caffeine.newBuilder()
        .maximumSize(10000)
        .expireAfterWrite(5, TimeUnit.MINUTES)
        .build();

    // L2缓存 - Redis分布式缓存
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // L3缓存 - 数据库
    @Autowired
    private UserPermissionRepository permissionRepository;

    public Boolean getCachedPermission(String permissionKey) {
        // 1. L1缓存查找
        Boolean result = l1Cache.getIfPresent(permissionKey);
        if (result != null) {
            return result;
        }

        // 2. L2缓存查找
        result = (Boolean) redisTemplate.opsForValue().get("perm:" + permissionKey);
        if (result != null) {
            // 回填L1缓存
            l1Cache.put(permissionKey, result);
            return result;
        }

        return null;
    }

    public void cachePermission(String permissionKey, boolean hasPermission) {
        // 1. 缓存到L1
        l1Cache.put(permissionKey, hasPermission);

        // 2. 缓存到L2
        redisTemplate.opsForValue().set(
            "perm:" + permissionKey,
            hasPermission,
            Duration.ofMinutes(15)
        );
    }

    public void invalidateUserPermissions(Long userId) {
        // 1. 清除L1缓存中的用户权限
        l1Cache.asMap().keySet().removeIf(key -> key.startsWith("user:" + userId));

        // 2. 清除L2缓存中的用户权限
        Set<String> keys = redisTemplate.keys("perm:user:" + userId + ":*");
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }

    public void invalidateResourcePermissions(String resource, Long resourceId) {
        // 1. 清除L1缓存
        String pattern = "*:" + resource + ":" + resourceId;
        l1Cache.asMap().keySet().removeIf(key -> key.contains(resource + ":" + resourceId));

        // 2. 清除L2缓存
        Set<String> keys = redisTemplate.keys("perm:*:" + resource + ":" + resourceId + ":*");
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }
}
```

### 动态权限配置

**权限配置管理**
```java
@RestController
@RequestMapping("/api/admin/permissions")
@RequirePermission(resource = "PERMISSION", action = "MANAGE")
public class PermissionConfigController {

    @Autowired
    private PermissionConfigService configService;

    @PostMapping("/roles/{roleId}/permissions")
    public ResponseEntity<Void> assignPermissionToRole(
            @PathVariable Long roleId,
            @RequestBody PermissionAssignmentRequest request) {

        configService.assignPermissionToRole(roleId, request);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/roles/{roleId}/permissions/{permissionId}")
    public ResponseEntity<Void> revokePermissionFromRole(
            @PathVariable Long roleId,
            @PathVariable Long permissionId) {

        configService.revokePermissionFromRole(roleId, permissionId);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/users/{userId}/spaces/{spaceId}/roles")
    public ResponseEntity<Void> assignUserToSpaceRole(
            @PathVariable Long userId,
            @PathVariable Long spaceId,
            @RequestBody UserRoleAssignmentRequest request) {

        configService.assignUserToSpaceRole(userId, spaceId, request);
        return ResponseEntity.ok().build();
    }
}

@Service
@Transactional
public class PermissionConfigService {

    @Autowired
    private RolePermissionRepository rolePermissionRepository;

    @Autowired
    private PermissionCacheService cacheService;

    @Autowired
    private PermissionAuditService auditService;

    @Autowired
    private ApplicationEventPublisher eventPublisher;

    public void assignPermissionToRole(Long roleId, PermissionAssignmentRequest request) {
        // 1. 验证角色和权限存在
        Role role = roleRepository.findById(roleId)
            .orElseThrow(() -> new EntityNotFoundException("Role not found"));

        Permission permission = permissionRepository.findById(request.getPermissionId())
            .orElseThrow(() -> new EntityNotFoundException("Permission not found"));

        // 2. 检查是否已存在
        if (rolePermissionRepository.existsByRoleIdAndPermissionId(roleId, request.getPermissionId())) {
            throw new DuplicatePermissionException("Permission already assigned to role");
        }

        // 3. 创建权限分配
        RolePermission rolePermission = new RolePermission();
        rolePermission.setRole(role);
        rolePermission.setPermission(permission);
        rolePermission.setGrantedBy(getCurrentUserId());
        rolePermission.setCreatedAt(LocalDateTime.now());

        rolePermissionRepository.save(rolePermission);

        // 4. 清除相关缓存
        cacheService.invalidateRolePermissions(roleId);

        // 5. 记录审计日志
        auditService.logPermissionAssignment(roleId, request.getPermissionId(), getCurrentUserId());

        // 6. 发布权限变更事件
        eventPublisher.publishEvent(new PermissionChangedEvent(roleId, "PERMISSION_ASSIGNED"));
    }

    public void assignUserToSpaceRole(Long userId, Long spaceId, UserRoleAssignmentRequest request) {
        // 1. 验证用户、空间、角色存在
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new EntityNotFoundException("User not found"));

        Space space = spaceRepository.findById(spaceId)
            .orElseThrow(() -> new EntityNotFoundException("Space not found"));

        Role role = roleRepository.findById(request.getRoleId())
            .orElseThrow(() -> new EntityNotFoundException("Role not found"));

        // 2. 验证角色级别匹配
        if (role.getLevel() != RoleLevel.SPACE) {
            throw new InvalidRoleException("Role level must be SPACE for space assignment");
        }

        // 3. 检查是否已存在相同分配
        Optional<UserSpaceRole> existing = userSpaceRoleRepository
            .findByUserIdAndSpaceIdAndRoleId(userId, spaceId, request.getRoleId());

        if (existing.isPresent()) {
            throw new DuplicateAssignmentException("User already has this role in the space");
        }

        // 4. 创建用户空间角色分配
        UserSpaceRole userSpaceRole = new UserSpaceRole();
        userSpaceRole.setUser(user);
        userSpaceRole.setSpace(space);
        userSpaceRole.setRole(role);
        userSpaceRole.setGrantedBy(getCurrentUserId());
        userSpaceRole.setExpiresAt(request.getExpiresAt());
        userSpaceRole.setStatus(PermissionStatus.ACTIVE);
        userSpaceRole.setCreatedAt(LocalDateTime.now());

        userSpaceRoleRepository.save(userSpaceRole);

        // 5. 清除用户权限缓存
        cacheService.invalidateUserPermissions(userId);

        // 6. 记录审计日志
        auditService.logUserRoleAssignment(userId, spaceId, request.getRoleId(), getCurrentUserId());

        // 7. 发布用户权限变更事件
        eventPublisher.publishEvent(new UserPermissionChangedEvent(userId, "SPACE_ROLE_ASSIGNED"));
    }
}
```

### 审计日志系统

**权限审计服务**
```java
@Service
public class PermissionAuditService {

    @Autowired
    private AuditLogRepository auditLogRepository;

    @Async
    public void logAuthentication(Long userId, ClientInfo clientInfo) {
        AuditLog log = AuditLog.builder()
            .userId(userId)
            .action("AUTHENTICATION")
            .resourceType("USER")
            .resourceId(userId.toString())
            .clientIp(clientInfo.getIpAddress())
            .userAgent(clientInfo.getUserAgent())
            .timestamp(LocalDateTime.now())
            .success(true)
            .build();

        auditLogRepository.save(log);
    }

    @Async
    public void logPermissionCheck(Long userId, String resource, String action,
                                 Long resourceId, boolean granted) {
        AuditLog log = AuditLog.builder()
            .userId(userId)
            .action("PERMISSION_CHECK")
            .resourceType(resource)
            .resourceId(resourceId != null ? resourceId.toString() : null)
            .details(String.format("Action: %s, Granted: %s", action, granted))
            .timestamp(LocalDateTime.now())
            .success(granted)
            .build();

        auditLogRepository.save(log);
    }

    @Async
    public void logPermissionAssignment(Long roleId, Long permissionId, Long grantedBy) {
        AuditLog log = AuditLog.builder()
            .userId(grantedBy)
            .action("PERMISSION_ASSIGNMENT")
            .resourceType("ROLE")
            .resourceId(roleId.toString())
            .details(String.format("Assigned permission %d to role %d", permissionId, roleId))
            .timestamp(LocalDateTime.now())
            .success(true)
            .build();

        auditLogRepository.save(log);
    }

    public List<AuditLogDto> getPermissionAuditLogs(Long userId, LocalDateTime from, LocalDateTime to) {
        List<AuditLog> logs = auditLogRepository.findByUserIdAndTimestampBetween(userId, from, to);
        return logs.stream()
            .map(AuditLogDto::from)
            .collect(Collectors.toList());
    }
}
```

## 数据库设计

```sql
-- 空间表
CREATE TABLE spaces (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    code VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    status ENUM('ACTIVE', 'INACTIVE', 'SUSPENDED') DEFAULT 'ACTIVE',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_code (code),
    INDEX idx_status (status)
);

-- 渠道表
CREATE TABLE channels (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    code VARCHAR(50) NOT NULL,
    name VARCHAR(100) NOT NULL,
    space_id BIGINT NOT NULL,
    type ENUM('PUBLIC', 'PRIVATE', 'RESTRICTED') DEFAULT 'PUBLIC',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (space_id) REFERENCES spaces(id),
    UNIQUE KEY uk_space_code (space_id, code),
    INDEX idx_space_id (space_id),
    INDEX idx_type (type)
);

-- 角色表
CREATE TABLE roles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    code VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    type ENUM('SYSTEM', 'CUSTOM') DEFAULT 'CUSTOM',
    level ENUM('SPACE', 'CHANNEL', 'DOCUMENT') NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_code (code),
    INDEX idx_type_level (type, level)
);

-- 权限表
CREATE TABLE permissions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    code VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    resource VARCHAR(50) NOT NULL,
    action VARCHAR(50) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_code (code),
    INDEX idx_resource_action (resource, action)
);

-- 角色权限关联表
CREATE TABLE role_permissions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    role_id BIGINT NOT NULL,
    permission_id BIGINT NOT NULL,
    granted_by BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (role_id) REFERENCES roles(id),
    FOREIGN KEY (permission_id) REFERENCES permissions(id),
    FOREIGN KEY (granted_by) REFERENCES users(id),
    UNIQUE KEY uk_role_permission (role_id, permission_id),
    INDEX idx_role_id (role_id),
    INDEX idx_permission_id (permission_id)
);

-- 用户空间角色关联表
CREATE TABLE user_space_roles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    space_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    granted_by BIGINT,
    expires_at TIMESTAMP NULL,
    status ENUM('ACTIVE', 'SUSPENDED', 'REVOKED') DEFAULT 'ACTIVE',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (space_id) REFERENCES spaces(id),
    FOREIGN KEY (role_id) REFERENCES roles(id),
    FOREIGN KEY (granted_by) REFERENCES users(id),
    UNIQUE KEY uk_user_space_role (user_id, space_id, role_id),
    INDEX idx_user_id (user_id),
    INDEX idx_space_id (space_id),
    INDEX idx_expires_at (expires_at),
    INDEX idx_status (status)
);

-- 用户渠道角色关联表
CREATE TABLE user_channel_roles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    channel_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    granted_by BIGINT,
    expires_at TIMESTAMP NULL,
    status ENUM('ACTIVE', 'SUSPENDED', 'REVOKED') DEFAULT 'ACTIVE',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (channel_id) REFERENCES channels(id),
    FOREIGN KEY (role_id) REFERENCES roles(id),
    FOREIGN KEY (granted_by) REFERENCES users(id),
    UNIQUE KEY uk_user_channel_role (user_id, channel_id, role_id),
    INDEX idx_user_id (user_id),
    INDEX idx_channel_id (channel_id),
    INDEX idx_expires_at (expires_at),
    INDEX idx_status (status)
);

-- 审计日志表
CREATE TABLE audit_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT,
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(50),
    resource_id VARCHAR(100),
    details TEXT,
    client_ip VARCHAR(45),
    user_agent TEXT,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    success BOOLEAN DEFAULT TRUE,
    FOREIGN KEY (user_id) REFERENCES users(id),
    INDEX idx_user_id (user_id),
    INDEX idx_action (action),
    INDEX idx_timestamp (timestamp),
    INDEX idx_resource (resource_type, resource_id)
);
```

## 依赖关系

**前置依赖**:
- 001: Spring Boot平台搭建

**后续任务依赖此任务**:
- 006: JSON数据管理系统 (数据权限控制)

## 工作量估算

**规模**: L (大型)
**预估时间**: 2-3周
**并行性**: true (可与搜索功能并行)

### 分解任务
1. 三层权限模型设计和数据库实现 (3天)
2. JWT认证服务开发 (3天)
3. 权限检查和继承逻辑 (4天)
4. 多级缓存策略实现 (3天)
5. 动态权限配置接口 (3天)
6. 审计日志系统 (2天)
7. 权限拦截器和注解 (2天)
8. 单元测试和集成测试 (3天)

## 完成定义

任务完成需满足以下条件：
1. 所有验收标准的性能指标达标
2. 权限检查逻辑通过安全测试
3. 并发权限验证性能达到要求
4. 权限缓存策略优化完成
5. 审计日志完整性验证通过
6. 代码覆盖率达到90%以上

## 风险与缓解

**安全风险**:
- JWT密钥泄露 → 定期轮换密钥，使用HSM管理
- 权限提升攻击 → 严格权限检查，最小权限原则
- 缓存中敏感信息泄露 → 加密缓存内容，设置合理过期时间

**性能风险**:
- 权限检查延迟过高 → 优化缓存策略，异步权限预加载
- 缓存穿透和雪崩 → 布隆过滤器，缓存预热机制

**业务风险**:
- 权限配置错误 → 权限变更审批流程，回滚机制
- 权限继承逻辑复杂 → 详细文档，自动化测试覆盖
